%-----------------------------------------------------------------------
%
%     This file is part of the Code_Saturne Kernel, element of the
%     Code_Saturne CFD tool.
%
%     Copyright (C) 1998-2011 EDF S.A., France
%
%     contact: saturne-support@edf.fr
%
%     The Code_Saturne Kernel is free software; you can redistribute it
%     and/or modify it under the terms of the GNU General Public License
%     as published by the Free Software Foundation; either version 2 of
%     the License, or (at your option) any later version.
%
%     The Code_Saturne Kernel is distributed in the hope that it will be
%     useful, but WITHOUT ANY WARRANTY; without even the implied warranty
%     of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%     GNU General Public License for more details.
%
%     You should have received a copy of the GNU General Public License
%     along with the Code_Saturne Kernel; if not, write to the
%     Free Software Foundation, Inc.,
%     51 Franklin St, Fifth Floor,
%     Boston, MA  02110-1301  USA
%
%-----------------------------------------------------------------------
\documentclass[a4paper,10pt,twoside]{article}

%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PACKAGES OBLIGATOIRES
\usepackage{csdoc}
% MACROS SUPPLEMENTAIRES
\usepackage{csmacros}
\usepackage[usenames, dvipsnames]{color}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PACKAGES ET COMMANDES POUR LE DOCUMENTS PDF ET LES HYPERLIENS
\hypersetup{%
  pdftitle = {CodeSaturne installation guide},
  pdfauthor = {MFEE},
  pdfpagemode = UseOutlines
}
\pdfinfo{/CreationDate (D:20100802000000-01 00 )}
%
% To have thumbnails upon opening the document under ACROREAD
% pdfpagemode = UseThumbs
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Info for title pages
\titreCS{\CS version~\verscs installation guide}

\docassociesCS{}
\resumeCS{This document presents all the necessary elements to install
with \CS version \verscs.

\begin{center}
\large{WORK IN PROGRESS}
\end{center}
}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Document start
\begin{document}

\def\contentsname{\textbf{\normalsize TABLE OF CONTENTS}\pdfbookmark[1]{Table of
contents}{contents}}

\pdfbookmark[1]{Flyleaf}{pdg}
\large
\makepdgCS
\normalsize

\passepage

\begin{center}\begin{singlespace}
\tableofcontents
\end{singlespace}\end{center}

\section{Installation basics\label{sec:install_basics}}

The installation scripts of \CS are based on the GNU Autotools,
(Autoconf, Automake, and Libtool), so it should be familiar for many
administrators. A few remarks are given here:

\begin{itemize}
\item As with most software with modern build systems, it is recommended
      to build the code in a separate directory from the sources. This
      allows multiple builds (for example production and debug), and is
      considered good practice. Building directly in the source tree is
      not regularly tested, and is not guaranteed to work, in addition
      to ``polluting'' the source directory with build files.
\item By default, optional libraries which may be used by \CS are
      enabled automatically if detected in default search paths
      (i.e. \texttt{/usr/} and \texttt{/usr/local}. To find libraries
      associated with a package installed in an alternate path,
      a \texttt{--with-<package>=...} option to the \texttt{configure} script
      must given. To disable the use of a library which would be
      detected automatically, a matching \texttt{--without-<package>} option
      must be passed to \texttt{configure} instead.
\item Most third-party libraries usable by \CS are considered optional,
      and are simply not used if not detected, but the libraries needed by
      the GUI are considered mandatory, unless the \texttt{--disable-gui}
      or \texttt{--disable-frontend} option is explicitly used.
\end{itemize}

When the prerequisites are available, and a build directory
created, building \CS and its documentation may be as simple as running:

\fbox{\begin{minipage}{\textwidth}\texttt{\\
\$ ../../saturne/configure\\
\$ make\\
\$ make install\\
\$ make pdf\\
\$ make install-pdf
}\end{minipage}}

The following chapters give more details on \CS's recommended
third-party libraries, configuration recommendations, troubleshooting,
and post-installation options.

\section{Third-Party libraries\label{sec:ext_lib}}

For a minimal build of \CS, a Posix system with a C and a Fortran compiler,
a Python interpreter and a {\tt make} tool should be sufficient.
For parallel runs, an MPI library is also necessary.
To build an use the GUI, Libxml2 and PyQt4 (which in turn requires
Qt4 and SIP) are required.
Other libraries may be used for additional mesh format options,
as well as to improve performance. A list of those libraries
and their role is given in \S\ref{sec:list_ext_lib}.

\subsection{Installing third-party libraries for \CS\label%
{sec:obtain_ext_lib}}

Third-Party libraries usable with \CS may be installed in several
ways:

\begin{itemize}
\item On many Linux systems, most of libraries listed in
      \S\ref{sec:list_ext_lib} are available through the distribution's
      package manager.\footnote{On Mac OS X systems, package managers such as
      Fink or MacPorts also provide package management, even though the
      base system does not.} This requires administrator privileges,
      but is by far the easiest way to install third-party libraries
      for \CS.

      Note that distributions usually split libraries or tools into runtime
      and development packages, and that although some packages are
      installed by default on many systems, this is generally not the
      case for the associated development headers. Development
      packages usually have the same name as the matching runtime package,
      with a \texttt{-dev} postfix added. For example, on a Debian or
      Ubuntu system ,\texttt{libxml2} is usually installed by default,
      but \texttt{libxml2-dev} must also be installed for the \CS
      build to be able to use the former.

\item On many large compute clusters, Environment Modules allow
      the administrators to provide multiple versions of many
      scientific libraries, as well us compilers or MPI libraries,
      using the \texttt{module} command. More details on
      Environment Modules may be found at \url{http://modules.sourceforge.net}.
      When being configured and installed \CS checks for modules loaded
      with the \texttt{module} command, and records the list of loaded
      modules. Whenever running that build of \CS, the modules detected
      at installation time will be used, rather than those defined by
      default in the user's environment. This allows using versions of
      \CS built with different modules safely and easily, even if the
      user may be experimenting with other modules for various purposes.

\item If not otherwise available, third-party software may be compiled
      an installed by an administrator or a user. An administrator
      will choose where software may be installed, but for a user
      without administrator privileges or write access to
      \texttt{usr/local}, installation to a user account is often
      the only option. None of the third-party libraries usable
      by \CS require administrator privileges, so they may all be
      installed normally in a user account, provided the user
      has sufficient expertise to install them. This is usually not
      complicated (provided one reads the installation instructions,
      and is prepared to read error messages if something goes wrong),
      but even for an experienced user or administrator, compiling
      and installing 5 or 6 libraries as a prerequisite significantly
      increases the effort required to install \CS.

      Even though it is more time-consuming, compiling and installing
      third-party software may be necessary when no matching packages
      or Environment Modules are available, or when a more recent version
      or a build with different options is desired.
\end{itemize}

\subsection{List of third-party libraries usable by \CS\label%
{sec:list_ext_lib}}

The list of third-party software usable with \CS is provided here:

\begin{itemize}

\item BLAS (Basic Linear Algebra Subroutines) may be used for certain
      operations such as vector sums, dot products, etc.
      If no third-party BLAS is provided, \CS reverts to its own
      implementation of BLAS routines, similar to the legacy Netlib BLAS,
      so no functionnality is lost here. With optimized BLAS such as
      Atlas, MKL, ESSL, and others, simple operations such as vector
      dot product, $Ax+y$, and such are often an order of magnitude
      faster than with the usual compiler optimizations, leading to an
      overall performance increase of about 10\%.

\item PyQt4 is required by the \CS GUI. PyQt4 in turn requires Qt4,
      Python,and SIP. Without this library, the GUI may not be built,
      although XML files generated with another install of \CS
      may be used if Libxml2 is available.

\item Libxml2 is required to read XML files edited with the GUI.
      If this library is not available, only user subroutines may
      be used to setup data.

\item HDF5 is necessary for MED, and may also be used by CGNS.

\item CGNSlib is necessary to read or write mesh and visualization files
      using the CGNS format, available as an export format with many
      third-party meshing tools,

\item MED is necessary to read or write mesh and visualization files
      using the MED format, mainly used by the SALOME platform.

\item libCCMIO is necessary to import mesh files generated by
      \starccmp using its native format.

\item \scotch or \ptscotch may be used to optimize mesh partitioning.
      Depending on the mesh, parallel computations with meshes partitioned
      with these libraries may be from 10\% to 50\% faster than using the
      built-in space-filling curve based partitioning.

      As \scotch and \ptscotch use symbols with the same names, only
      one of the 2 may be used. If both are detected, \ptscotch is used.

\item \metis or \parmetis are alternative mesh partitioning libraries.
      These libraries have a separate source tree, but some of their
      functions have identical names, so only one of the 2 may be used.
      If both are available, \parmetis will be used. Partitioning
      quality is usually slightly lower than that obtained with \scotch or
      \ptscotch, but these libraries are faster.

      Though broadly available, the licence is quite restrictive,
      so \scotch and \ptscotch may be preferred (\CS may be built with both
      \metis and \scotch libraries).

\end{itemize}

For developers, the GNU autotools (Autoconf, Automake, Libtool) as
well as gettext will be necessary. To build the documentation,
pdf\LaTeX{} and \texttt{fig2dev} (part of TransFig) will be necessary.

\subsection{Notes on some third-party tools and libraries}

\subsubsection{Python and PyQt4\label{sec:ext:python}}

\CS requires a Python interpreter, with Python version 2.4 or above.
The base scripts should work both with Python 2 or Python 3 versions,
but have not been tested recently with the latter. The GUI is Python 2
only, so using Python 3 is not currently recommended.

While \CS make heavy use of Python, this is for scripts and for the GUI only;
The solver only uses compiled code, so we may for example use
a 32-bit version of Python with 64-bit \CS libraries and executables.

The GUI is written in PyQt4 (Python bindings for Qt4), so but Qt4 and
the matching Python bindings must be available. On most modern
Linux distributions, this is available through the package manager,
which is by far the preferred solution. When running on a system which does
not provide these libraries, there are several alternatives:

\begin{itemize}

\item build \CS without the GUI. If built with Libxml2, XML files
      produced with the GUI are still usable, so if an install of \CS
      with the GUI is available on an other machine, the XML files
      may be copied on the current machine. This is certainly not an optimal
      solution, but in the case where users have a mix of desktop or virtual
      machines with modern Linux distributions and PyQt4 installed, and
      a compute cluster with an older system, this may avoid requiring
      a build of Qt4 and PyQt4 on the cluster if users find this too daunting.

\item Install a local Python interpreter, and add Qt4 bindings to this
      interpreter.

      Python (\url{http://www.python.org}) and Qt4
      (\url{http://qt.nokia.com/products}) must be downloaded  and
      installed first, in any order. The installation instructions of
      both of these tools are quite clear, and though the installation of these
      large packages (especially Qt4) may be a lengthy process in terms of
      compilation time, but is well automated and usually devoid of nasty
      surprises.\footnote{The only case in which the \CS developers
      have has issues with Qt4 was when trying to force an install into
      64-bit mode with the GNU compilers (version 4.1.2) on a PowerPC 64
      architecture running SLES 10 Linux, on which compilers default
      to building 32 bit code, although 64 bit is available. Using default
      options on the same machine led to a perfectly functional 32-bit Qt
      installation}.

      Once Python is installed, the SIP bindings generator
      (\url{http://riverbankcomputing.co.uk/software/sip/intro})
      must also be installed. This is a small package, and configuring it
      simply requires running \texttt{python configure.py} in its source
      tree, using the Python interpreter just installed.

      Finally, the PyQt4 bindings
      (\url{http://riverbankcomputing.co.uk/software/pyqt/intro}) may be
      installed, in a manner similar to SIP.

      When this is finished, the local Python interpreter contains
      the PyQt4 bindings, and may be used by \CS's \texttt{configure}
      script by passing \texttt{PYTHON=<path\_to\_python\_executable}.
     
\item add Python Qt4 bindings as a Python extension module for an existing
      Python installation. This is a more elegant solution than the previous
      one, and avoids requiring rebuilding Python, but if the user does not
      have administrator privileges, the extensions will be placed in a
      directory that is not on the default Python extension search path, and
      that must be added to the \texttt{PYTHONPATH} environment variable.
      This works fine, but for all users using this build of \CS, the
      \texttt{PYTHONPATH} environment variable will need to be
      set.\footnote{In the future, the \CS installation scripts could check
      the \texttt{PYTHONPATH} variable and save its state in the build so as
      to ensure all the requisite directories are searched for.}

      The process is similar to the previous one, but SIP and PyQt4
      installation requires a few additional configuration options
      in this case. See the SIP and PyQt4 reference guides for
      detailed instructions, especially the \emph{Building a Private
      Copy of the SIP Module} section of the SIP guide.

\end{itemize}

\subsubsection{\scotch and \ptscotch\label{sec:ext:scotch}}

For better performance, \ptscotch may be built to use threads with concurrent
MPI calls. This requires initializing MPI with \texttt{MPI\_Init\_thread}
with \texttt{MPI\_THREAD\_MULTIPLE} (instead of the more restrictive
\texttt{MPI\_THREAD\_SERIALIZED}, \texttt{MPI\_THREAD\_FUNNELED}, or
\texttt{MPI\_THREAD\_SINGLE}, or simply using \texttt{MPI\_Init}).
As \CS does not support thread models in which different threads may call
MPI functions simultaneously, and the use of \texttt{MPI\_THREAD\_MULTIPLE}
may carry a performance penalty, we prefer to sacrifice some of
\ptscotch's performance by requiring that it be compiled without the
\texttt{-DSCOTCH\_PTHREAD} flag. This is not detected at compilation time,
but with recent MPI libraries, \ptscotch will complain at run tile
if it notices that the MPI thread safety level in insufficient.

Detailed build instructions, including troubleshooting instructions,
are given in the source tree's \texttt{INSTALL.txt} file.
In case of trouble, note especially the explanation relative to the
\texttt{dummysizes} executable, which is run to determine the
sizes of structures. On BlueGene/P type machines, it may be necessary
to start the build process, let it fail, run this executable
manually using \texttt{mpirun}, then pursue the build process.

\section{Preparing for build\label{sec:prepare}}

If the code was obtained as an archive, it must be unpacked:

\texttt{tar xvzf saturne.tar.gz}

If for example you unpacked the directory in a directory
named \texttt{/home/user/Code\_Saturne}, you will now
have a directory named \texttt{/home/user/Code\_Saturne/saturne}.

For developers obtaining the code was obtained through a version control
system such as Subversion, an additional step is required:

\fbox{\begin{minipage}{\textwidth}\texttt{\\
\$ cd saturne\\
\$ autoreconf -vi\\
\$ cd ..
}\end{minipage}}

It recommended to build the code in a separate directory from the source.
This also allows multiple builds, for example, building both an
optimized and a debugging version. In this case, choose a consistent
naming scheme, using an additional level of sub-directories,
for example:

\fbox{\begin{minipage}{\textwidth}\texttt{\\
\$ mkdir saturne\_build\\
\$ cd saturne\_build\\
\$ mkdir prod\\
\$ cd prod%
}\end{minipage}}

Some older system's {\tt make} command may not support compilation
in a directory different from the source directory ({\tt VPATH}
support). In this case, installing and using the GNU {\tt gmake}
tool instead of the native {\tt make} is recommended. 

\section{Configuration\label{sec:config}}

\CS uses a build system based on the GNU autotools, which includes
its own documentation.

To obtain the full list of available configuration options,
run: {\tt configure~--help}.

Note that for all options starting with {\tt --enable-}, 
there is a matching options with {\tt --disable-}. Similarly,
for every {\tt --with-}, {\tt --without-} is also possible.

Select configuration options, then run {\tt configure}, for example:

\fbox{\begin{minipage}{\textwidth}\texttt{\\
\$ ../../saturne/configure \textbackslash \\
\textcolor{Violet}{--prefix}=/home/user/Code\_Saturne/2.1/arch/prod
\textbackslash \\
\textcolor{Violet}{--with-mpi}=/home/user/opt/mpich2-1.4
}\end{minipage}}

In the rest of this section, we will assume that we are in
a build directory separate from sources, as described in
\S\ref{sec:prepare}. In different examples, we assume
that third-party libraries used by \CS are either available
as part of the base system (i.e. as packages in a Linux distribution),
as Environment Modules, or are installed under a separate path.

For our examples, Let us define environment variables repectively reflecting the \CS
source path, installation path, and a path where optional libraries are installed:

\fbox{\begin{minipage}{\textwidth}\texttt{\\
\$ \textcolor{OliveGreen}{SRC\_PATH}=/gpfs/home/projects/Code\_Saturne/2.1 \\
\$ \textcolor{OliveGreen}{INSTALL\_PATH}=/gpfs/home/projects/Code\_Saturne/2.1 \\
\$ \textcolor{OliveGreen}{CS\_OPT}=/gpfs/home/projects/opt
}\end{minipage}}

\subsection{Shared or static builds\label{sec:config:shared}}

By default, on most architectures, both shared and static libraries
for \CS will be built, and the executables will be linked with shared
libraries by default. To disable either shared or static libraries,
add either {\tt --disable-shared} or {\tt --disable-static}
to the options passed to {\tt configure}. This will speed-up the build,
process as each file will only be built once, and not twice.

In some cases, a shared build may fail due to some dependencies
on static-only MPI libraries. In this case, {\tt --disable-shared}
will be necessary. Disabling shared libraries has also been seen
to avoid issues with linking on Mac OSX systems.

In any case, be careful if you switch from one option to the other: as
linking will be done with shared libraries by default, a build
with static libraries only will not completely overwrite a build using
shared libraries, so uninstalling the previous build first
is recommended.

\subsection{Example configuration commands\label{sec:config:examples}}

Most available prerequisites are auto-detected, so to install the
code to the default \texttt{/usr/local} sub-directory,
a command such as:

\texttt{\$ ../../saturne/configure}

should be sufficient.

For a single architecture and an account named projects, with
a specific installation of the CGNS and MED IO librairies,
based on a system-wide installation of HDF5 (which will be auto-detected),
and using MPI compiler wrappers, a configure command may look like this:

\fbox{\begin{minipage}{\textwidth}\texttt{\\
\$ /home/user/Code\_Saturne/2.1/saturne/configure \textbackslash \\
\textcolor{Violet}{--prefix}=/home/user/Code\_Saturne/2.1/arch/prod
\textbackslash \\
\textcolor{Violet}{--with-med}=/home/user/opt/med-3.0 \textbackslash \\
\textcolor{Violet}{--with-cgns}=/home/user/opt/cgns-3.1 \textbackslash \\
\textcolor{red}{CC}=mpicc \textcolor{red}{FC}=gfortran
}\end{minipage}}

For a side-by-side debug build, we simply replace \texttt{prod} by
\texttt{dbg} in the \texttt{--prefix} option, and add
\texttt{--enable-debug} to the configure command.

For an install using a reference account named projects on which multiple
versions and architectures of the code should be available,
configure commands with all bells and whistles (except SALOME support) for a
build on a cluster named \texttt{ivanoe}, using the Intel compilers
(made available through environment modules) may look like this:

\fbox{\begin{minipage}{\textwidth}\texttt{\\
\$ \textcolor{Magenta}{module purge} \\
\$ \textcolor{Magenta}{module load} intel\_compilers/12.0.3.174 \\
\$ \textcolor{Magenta}{module load} open\_mpi/gcc/1.4.3 \\
\$ \textcolor{OliveGreen}{\$SRC\_PATH}/saturne/configure \textbackslash \\
\textcolor{Violet}{--prefix}=\textcolor{OliveGreen}{\$INSTALL\_PATH}/arch/ivanoe\_ompi
\textbackslash \\
\textcolor{Violet}{--with-blas}=/opt/intel/composerxe-2011.3.174/mkl \textbackslash \\
\textcolor{Violet}{--with-libxml2}=\textcolor{OliveGreen}{\$CS\_OPT}/libxml2-2.3.32/arch/ivanoe\_ompi \textbackslash \\
\textcolor{Violet}{--with-hdf5}=\textcolor{OliveGreen}{\$CS\_OPT}/hdf5-1.8.6/arch/ivanoe\_ompi
\textbackslash \\
\textcolor{Violet}{--with-med}=\textcolor{OliveGreen}{\$CS\_OPT}/med-3.0/arch/ivanoe\_ompi
\textbackslash \\
\textcolor{Violet}{--with-cgns}=\textcolor{OliveGreen}{\$CS\_OPT}/cgns-3.1/arch/ivanoe\_ompi \textbackslash \\
\textcolor{Violet}{--with-ccm}=\textcolor{OliveGreen}{\$CS\_OPT}/libccmio-2.6.19/arch/ivanoe\_ompi \textbackslash \\
\textcolor{Violet}{--with-scotch}=\textcolor{OliveGreen}{\$CS\_OPT}/scotch-5.1.11/arch/ivanoe\_ompi \textbackslash \\
\textcolor{Violet}{--with-metis}=\textcolor{OliveGreen}{\$CS\_OPT}/parmetis-3.2/arch/ivanoe\_ompi \textbackslash \\
\textcolor{Violet}{--with-syrthes}=/home/projects/syrthes3.4.3 \textbackslash \\
\textcolor{red}{CC}=mpicc \textcolor{red}{FC}=ifort
\textcolor{red}{CXX}=icpc
}\end{minipage}}

In the example above, we have appended the \texttt{\_ompi} postfix
to the architecture name, in case we intend to install 2 builds,
with different MPI libraries (such as Open MPI and MPICH2).
Note that optional libraries using MPI must also use the same MPI
library. This is the case for \ptscotch or \parmetis, but also HDF5,
CGNS, and MED if they are built with MPI-IO support.
Similarly, C++ and Fortran libraries, and even C libraries built
with recent optimizing C compilers, may require runtime libraries
associated to that compiler, so if versions using different compilers
are to be installed, it is recommended to use a naming scheme
which reflects this.

For additional side-by-side debug builds, we simply add \texttt{\_dbg} to
each \texttt{--prefix} option, and add \texttt{--enable-debug}
to the configure command.

\subsubsection{Cross-compiling}

On machines with different front-end and compute node architecturs,
such as IBM Blue Gene/P, cross-compiling is necessay.
To install and run \CS, 2 builds are recommended:

On the front-end, we have the ``main'' install (the one directly
used by the users). We will not need MPI, as this build is not intended for
calculations, but for the scripts, GUI, preprocessor, documentation:

\fbox{\begin{minipage}{\textwidth}\texttt{\\
\$ \textcolor{OliveGreen}{\$SRC\_PATH}/saturne/configure \textbackslash \\
\textcolor{Violet}{--prefix}=\textcolor{OliveGreen}{\$INSTALL\_PATH}/arch/frontend
\textbackslash \\
\textcolor{Violet}{--with-hdf5}=\textcolor{OliveGreen}{\$CS\_OPT}/hdf5-1.8.6/arch/frontend
\textbackslash \\
\textcolor{Violet}{--with-med}=\textcolor{OliveGreen}{\$CS\_OPT}/med-3.0/arch/frontend
\textbackslash \\
\textcolor{Violet}{--with-cgns}=\textcolor{OliveGreen}{\$CS\_OPT}/cgns-3.1/arch/frontend \textbackslash \\
\textcolor{Violet}{--with-scotch}=\textcolor{OliveGreen}{\$CS\_OPT}/scotch-5.1.11/arch/frontend \textbackslash \\
\textcolor{red}{PYTHON}=\textcolor{OliveGreen}{\$CS\_OPT}/python/arch/frontend/bin/python \textbackslash \\
\textcolor{red}{CFLAGS}="-m64" \textcolor{red}{FCFLAGS}="-m64" \textcolor{red}{CXXFLAGS}="-m64"
}\end{minipage}}

For the compute node, we use the same version of Python (which
is used only for the GUI and scripts, which only run on the front-end
or service nodes), but the compilers are cross-compilers for the
compute nodes:

\fbox{\begin{minipage}{\textwidth}\texttt{\\
\$ \textcolor{OliveGreen}{\$SRC\_PATH}/saturne/configure \textbackslash \\
\textcolor{Violet}{--prefix}=\textcolor{OliveGreen}{\$INSTALL\_PATH}/arch/bgp
\textbackslash \\
\textcolor{Violet}{--with-blas}=/opt/ibmmath/essl/4.4 \textbackslash \\
\textcolor{Violet}{--with-libxml2}=\textcolor{OliveGreen}{\$CS\_OPT}/libxml2-2.3.32/arch/bgp \textbackslash \\
\textcolor{Violet}{--with-hdf5}=\textcolor{OliveGreen}{\$CS\_OPT}/hdf5-1.8.6/arch/bgp
\textbackslash \\
\textcolor{Violet}{--with-med}=\textcolor{OliveGreen}{\$CS\_OPT}/med-3.0/arch/bgp
\textbackslash \\
\textcolor{Violet}{--with-cgns}=\textcolor{OliveGreen}{\$CS\_OPT}/cgns-3.1/arch/bgp \textbackslash \\
\textcolor{Violet}{--with-scotch}=\textcolor{OliveGreen}{\$CS\_OPT}/scotch-5.1.11/arch/bgp \textbackslash \\
\textcolor{Violet}{
--disable-sockets --disable-dlloader -disable-nls \textbackslash \\
--disable-frontend --enable-long-gnum \textbackslash
} \\
\textcolor{Magenta}{--build}=ppc64
\textcolor{Magenta}{--host}=bluegenep \textbackslash \\
\textcolor{red}{CC}=mpixlc\_r \textcolor{red}{FC}=bgxlf90\_r
\textcolor{red}{CXX}=mpixlcxx\_r \textbackslash \\
\textcolor{red}{PYTHON}=\textcolor{OliveGreen}{\$CS\_OPT}/python/arch/bgp/bin/python
}\end{minipage}}

Here, the \texttt{--build=ppc64 --host=bluegenep} options ensure the
\texttt{configure} script into cross-compilation mode.
In this example, the front-end node on which we are compiling is based
on an IBM Power architecture. With an Intel or AMD, architecture,
\texttt{--build=x86\_64} or \texttt{--build=amd64} should be used. For
the host (target) architecture, \texttt{--host=bluegenep} is recognized by
current GNU Autoconf versions, so it is preferred, but
\texttt{--host=ppc} also works well. Actually, any choice of build and host
architectures recognized by Autoconf would probably work,
as long as build and host are different.

The C++ compiler is also specified, as it will be needed for
the link stage due to C++ dependencies in the MED library: when building
with shared libraries, this is not necessary, but if the configuration
script is not able to link with MED using the C compiler, it tries
switching to the C++ compiler in case we are only using statically-linked
libraries (which is the case here).

Note that in the above examples, we specified an install of the \scotch
partitioning library both for the front-end and for the compute nodes.
The implies a serial build of \scotch on the front-end node, and a parallel
build (\ptscotch) on the compute nodes. Both are optional.
Similarly, \metis could be used on the front-end node, and \parmetis
on the compute nodes.

\subsection{Troubleshooting\label{sec:config:troubleshoot}}

If \texttt{configure} fails and reports an error, the message should
be sufficiently clear in most case to understand the cause of the
error and fix it. Do not forget that for libraries installed using
packages, the developement versions of those pacakges are also
necessary, so if configure fails to detect a package which you
beleive is installed, check the matching developement package.

Also, whether it succeeds or fails, \texttt{configure} generates
a file named \texttt{config.log}, which contains details on tests
run by the script, and is very useful to troubleshoot
configuation problems. When \texttt{configure} fails du to a given
third-part library, details on tests relative to that library
are found in the \texttt{config.log} file. The interesting information
is usually in the middle of the file, so you will need to search
for strings related to the library to find the test that failed
and detailed reasons for its failure.

\section{Compile and install\label{sec:compile}}

Once the code is configured, it may be compiled and installed;
for example, to compile the code (using 4 parallel threads),
then install it:

\texttt{\$ make -j 4 \&\& make install}

To compile the documentation, add:

\texttt{\$ make pdf \&\& make install-pdf}

To clean the build directory, keeping the configuration,
use \texttt{make clean};
To uninstall an installed build, use \texttt{make uninstall}.
To clear all configuration info, use \texttt{make distclean}
(\texttt{make uninstall} will not work after this).

\section{Post-install\label{sec:post}}

Once the code is installed, a post-install step may
be used for computing environments using a batch system,
or a separate front-end and build system:

Edit the \texttt{<install-prefix>/etc/code\_saturne.cfg},
and uncomment and define the \texttt{batch} section.
The name of the batch system should match one of the templates \\
in \texttt{<install-prefix>/share/code\_saturne/batch},
and those may also be edited if necessary to match the local
batch configuration{\footnote Some batch systems allow a wide
range of alternate and sometimes incompatible options or keywords,
and it is for all practical purposes impossible to determine
which options are allowed for a given setup, so editing the
batch template to match the local setup may be necessary.}

Also, the \texttt{compute\_versions} section allows the administrator
to define one or several alternate builds which will be used for
compute stages. This is especially useful for installation
on BlueGene type machines, where 2 separate builds are required
(one for the front-end nodes and one for the compute nodes).
The compute-node build may be configured using the
\texttt{--disable-frontend} option so as only to build and install
the components required to run on compute-nodes,
while the front-end build may be configured without MPI support.
The front-end build's post-install step allows definition of
the associated compute build.

\section{Installing for \syrthes coupling\label{sec:syrthes}}

When coupling with \syrthes using MPI, both \CS and \syrthes must
use the same MPI library, and must use the same version on the
PLE (Parallel Location and Exchange) library from \CS. By default, PLE
is built as a sub-library of \CS, but a standalone version may be
configured and built, using the \texttt{libple/configure} script
from the \CS source tree, instead of the top-level \texttt{configure}
script. \CS may then be configured to use the existing install of PLE
using the \texttt{--with-ple} option. Similarly, \syrthes must also
be configured to use PLE.

Alternatively, \syrthes may simply be configured to use the PLE
library from an existing \CS install.

\end{document}

